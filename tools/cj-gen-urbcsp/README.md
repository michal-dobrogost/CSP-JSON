# cj-gen-urbcsp

This tool generates binary random CSP instances in the CSP-JSON format. It is based on [Christian Bessiere's urbcsp](https://www.lirmm.fr/~bessiere/generator.html) with these additions:
* Updated to run on 64-bit machines.
* Use a dataformat (CSP-JSON) instead of a code dependency.
* The ability to share constraint definitions across constraint instantiations (see K).
* Improved error messages on invalid command line parameters.
* Use standardized UNIX return value conventions (main returns 0 on success).

Much of this readme originates from the original well.

## Output

This example is the last instance generated by invoking `cj-gen-urbcsp 100 10 10 10 100 100`.

```JSON
{
  "meta": {
    "id": "urbcsp/n100d10c10t10s100i99k10",
    "algo": "urbcsp",
    "params": {"n": 100, "d": 10, "c": 10, "t": 10, "s": 100, "i": 99, "k": 10}
  },
  "domains": [
    {"values": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}
  ],
  "vars": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  "constraintDefs": [
    {"noGoods": [[6, 6], [2, 0], [3, 8], [5, 7], [9, 6], [2, 7], [5, 6], [8, 2], [9, 9], [4, 8]]},
    {"noGoods": [[0, 3], [0, 1], [8, 0], [2, 2], [7, 6], [9, 1], [8, 4], [3, 0], [9, 2], [8, 8]]},
    {"noGoods": [[5, 0], [4, 6], [9, 2], [8, 2], [1, 2], [3, 5], [4, 8], [1, 1], [3, 3], [4, 0]]},
    {"noGoods": [[1, 4], [4, 5], [5, 3], [7, 8], [7, 2], [7, 1], [0, 0], [0, 4], [0, 5], [1, 9]]},
    {"noGoods": [[2, 0], [5, 9], [0, 8], [0, 2], [9, 0], [5, 1], [5, 4], [2, 7], [1, 6], [5, 0]]},
    {"noGoods": [[0, 5], [1, 1], [6, 3], [1, 8], [2, 4], [5, 6], [3, 5], [2, 8], [9, 9], [5, 3]]},
    {"noGoods": [[0, 7], [3, 6], [8, 8], [0, 8], [6, 1], [1, 4], [2, 0], [3, 2], [4, 1], [3, 0]]},
    {"noGoods": [[5, 5], [7, 8], [8, 2], [1, 8], [9, 7], [9, 2], [9, 3], [3, 1], [9, 9], [4, 8]]},
    {"noGoods": [[9, 0], [0, 1], [8, 7], [5, 8], [7, 4], [2, 2], [2, 1], [8, 4], [9, 8], [6, 9]]},
    {"noGoods": [[9, 0], [2, 4], [3, 3], [5, 0], [2, 7], [1, 4], [3, 9], [9, 6], [6, 8], [7, 0]]}
  ],
  "constraints": [
    {"id": 0, "vars": [17, 19]},
    {"id": 1, "vars": [57, 94]},
    {"id": 2, "vars": [10, 28]},
    {"id": 3, "vars": [1, 90]},
    {"id": 4, "vars": [55, 64]},
    {"id": 5, "vars": [9, 32]},
    {"id": 6, "vars": [3, 12]},
    {"id": 7, "vars": [52, 69]},
    {"id": 8, "vars": [11, 59]},
    {"id": 9, "vars": [14, 44]}
  ]
}
```

## Random uniform csp generators

Many csp researchers around the world use random uniform instances to evaluate their constraint satisfaction algorithms.
although it is generally agreed that the ultimate test of a csp
algorithm is its performance on "real world" (read, economically important) problems, there is also widespread consensus on the value of "laboratory" experimentation on random problems.

Random problems offer the following advantages for empirically
evaluating the performance of csp algorithms:

1. Large quantities can be generated, so that statistically significant means and variances can be reported.

2. It is easy to vary systematically the parameters of the generator and thus to observe how an algorithm's performance relates to, for example, the number of constraints.

3. It is easy to find parameters which generate problems of which 50% are soluble; on average such problems are particularly difficult and thus tend to highlight differences in algorithm performance.

4. A fourth benefit of random problems has not been much realized. For several reasons, using random problems should permit the easy interchange of problems among experimenters:
   * These problems embody no trade secrets or sensitive corporate information.
   * No specialized domain knowledge is required to understand them.
   * Instances can be succinctly encoded in JSON.

The goal of this cj-gen-urbcsp is promote benefit #4 by providing
csp researchers with a simple, compact program which can be
used to generate uniform, random, binary csps in JSON format.

## The random problem model

Although an infinite number of random csp instance generating models might be imagined, in practice most workers in the last few years have used a simple one, which takes four parameters:

* N: the number of variables in the problem.
* D: the number of values in the domain of each variable. Each variable has a domain of the same size.
* C: the number of constraints. All constraints are binary (between exactly two variables). The constraints are chosen at random from a uniform distribution. This number may be specified either as an integer or as a fraction between 0 and 1. For instance, if a problem has 20 variables, then the maximum number of constraints is 20*19/2 = 190. A particular problem could be specified with number of constraint equals 95 or 0.5.  the c function takes this parameter as an integer, so that it doesn't have to do rounding or truncation.
* T: the tightness of each constraint.  all constraints have the same tightness. Tightness refers to the number of value pairs which are disallowed by the constraint. The specific pairs are chosen at random from a uniform distribution. Tightness may be specified either as an integer or as a fraction between 0 and 1. For instance, if a problem has variables with domain size of 5, then the maximum number of value pairs disallowed by a constraint is 5*5 = 25. A particular problem could be specified with tightness of 5 or 0.2. The c function takes this parameter as an integer, so that it doesn't have to do rounding or truncation.
* K: The number of constraint definitions. If K < C then some of the K constraint definitions will be shared among the C constraint instantiations between variables. If omitted K = C.

The instances are also described by these additional parameters:
* S: the random seed used initially.
* I: the instance number in the sequence of instances generated.

## Implementation

The c program was designed to be easy to use and to make problems easy to replicate. In particular, our goals were:

* Truly uniform random instances.
* A well-defined and high quality pseudo-random number generator.

### Random numbers
**WARNING** This section is outdated. The quality of the random number generators given in _numerical recipes in c_ has been
<a href="https://www.uwyo.edu/buerkle/misc/wnotnr.html">questioned here</a>. The generator can not be changed without affecting backwards compatibility. However, focusing on a binary CSP data interchange format (JSON) instead of code for generating instances solves this going forward.

The c code includes an explicitly specified pseudo-random number generator. Relying on `rand()` or `random()`
functions defined by an operating system or local library of
course greatly reduces the likelihood that another researcher will
be able to duplicate the instances. We use a routine, `ran2`, from the well known *numerical recipes in c*, by william h. press et al.; The discussion there is well worth reading. This generator has a period of about 2.3 * 10^18. a brief quotation: "we think that, within the limits of its floating-point precision, ran2 provides perfect random numbers" (p. 281).

### Randomly selecting disallowed value pairs
The program uses the random number generator to select the disallowed or illegal value pairs in each constraint. This is an arbitrary decision; it would be equally possible to select the allowed
or valid pairs.
